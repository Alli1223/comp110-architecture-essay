% Please do not change the document class
\documentclass{scrartcl}

% Please do not change these packages
\usepackage[hidelinks]{hyperref}
\usepackage[none]{hyphenat}
\usepackage{setspace}
\doublespace

% You may add additional packages here
\usepackage{amsmath}

% Please include a clear, concise, and descriptive title
\title{A Comparison of Procedural Content Generators}

% Please do not change the subtitle
\subtitle{COMP110 - Computer Architecture Essay}

% Please put your student number in the author field
\author{AR185160}

\begin{document}

\maketitle

\abstract{This paper will evaluate and compare three articles; A Rhythm-Based Level Generator for 2-D platformers\cite{smith2009}, Procedural Content Generation Using Occupancy-Regulated Extension\cite{mawhorter2010} and Procedural Content Generation Using Patterns as Objectives\cite{dahlskog2014}. These articles all have their own techniques to procedurally generate content for a 2-D platformer. This article recommends that Launchpad: A Rhythm-Based Level Generator is the most appropriate PCG if a Indie developer is wanting to make a procedurally generated 2-D platformer. }

\section{Introduction}

The way in which we use Procedural Content Generators (PCG) to develop content for games is a vital part of the video game design process. With the recent release of popular procedurally generated games, such as Minecraft, Elite: Dangerous and The Binding of Isaac, it is important to choose a procedural content generator that suits your needs, as there are a lot of different implementations of PCG to choose from, each designed for a particular enviroment. The work is motivated by the complexity and variety of all the different approaches to Procedural Content Generation, and aims to provide a comparison of three different papers to make a recommendation based on qualities that would suit the needs for an Indie developer that would like to implement a PCG into their 2-D platformer game.

There is always going to be advantages and disadvantages of one PCG over another depending on the context. However in the context of a 2-D platformer, these are three PCG articles that are designed to generate levels in the style of Super Mario Bros(SMB).


1: Launchpad: A Rhythm-Based Level Generator for 2-D platformers\cite{smith2009}

2: Procedural Level Generation Using Occupancy-Regulated Extension \cite{mawhorter2010}

3: Procedural Content Generation Using Patterns as Objectives\cite{dahlskog2014} 

%Write your introduction here. A brief introduction is recommended, which should outline key details of the chosen topic and the reviewed papers, motivate the work, and provide a roadmap of key points to the reader. The motivation is quite important here, as essays should have a contribution (i.e., what is the point of the essay, and what does the reader take away from the essay) and the link between the motivation (in the introduction) and the contribution (in the conclusion) should be made clear.

\section{Review of Procedural Content Generation Articles}


The recommendation is based off the desirable characteristics in each PCG, in the context of what a Indie developer that would like to implement a PCG. The metrics that will be important to a Indie developer are flexibility(ease of implementation and customization of PCG), playability, \textit{leniency} , \textit{Linearity\footnote{leniency is how forgiving the level is to the player, E.g. levels with less obstacles or enemy's are less lenient. Linearity is a measure of the varying geometry of a level}}, \cite{smith2010} and amount of human authoring needed for content/levels.

\subsection{Launchpad: A Rhythm-Based Level Generator}

Launchpad generates levels out of small segments called ``\textit{rhythm groups}''  which are short, non-overlapping areas that contain a challenge for the player. I.e. a series of quick jumps or jumping back and forth between platforms. The rhythm groups are generated using a 2 tiered grammar \footnote{Grammar in this context meaning a set of rules for rewriting strings, which forms the basics of how procedural content generation works\cite{shaker2015}.} based approach.

The first stage of this creates a set of beats that correspond to a player action, this is good because it means the game can be improved by adding more varying player actions.
The second stage takes the player action and creates geometry based on its parameters, this is then added to the level as a ``rhythm group''. 

To achieve guaranteed playability of levels, Launchpad generates many different levels which are then tested against their leniency and linearity to find the best level. This design works well because it lets the program be very flexible, as each stage has its own metrics that can be edited to make the program look how the designer intended. Furthermore this will help eliminate any unwanted linearity that may occur.

However this approach is designed for a ``speedrun''  type of gameplay, and does not currently work well with exploration type of gameplay.


\subsection{Procedural Level Generation Using Occupancy-Regulated Extension}

This procedural level generator is to be able to generate levels without knowing anything about how the game works. This method works by using a library of chunks and assembling them based on a complex set of parameters. 

This Algorithm generates the content in 3 stages, firstly it selects the location at which to start generating geometry. It then selects chunks from the library that is then tested with its filtering and selection algorithms to see if it is appropriate to place at that location. Lastly that chunk is integrated within the existing content.

Compared to Launchpad, this method requires a large amount of human authored content to be available in order to get a varied level. Furthermore, this method is not very extensible as the more items are added to the library the longer it takes to generate a level. Even after the level is generated, it still requires a large amount of post-processing to make the game playable.

However when done correctly with the right settings, this approach can generate some very creative and complex levels, that neither of the other two generators can match.

This approach does not guarantee playable levels, which is a very undesirable property when creating a level.



\subsection{Procedural Content Generation Using Patterns as Objectives}

Dahlskog and Togelius take an interesting approach to PCG, by looking for patterns in the way levels are structured in an original game such as SMB, then analyzing that level design to generate levels that use the same level design techniques. This means that the levels can maintain a high quality, but still be varied at the same time.

This method works by identifying ``micro-patterns'' and ``meso-patterns'' in an existing game, such as SMB. Micro-patterns are a vertical 1-block wide slice of the level, and meso-patterns are the way in which micro-patterns are arranged. The generator then uses the micro-patterns as building blocks to generate a new level.

This PCG is not ideal for an indie developer as the implementation requires a version of an existing game to work, this means that the developer must create a game and a well designed level in order to generate more levels of the same type.







\subsection{comparisons}

Flexibility

Amount of human authoring needed for content/levels

Leniency

Linearity

Playability

Ease of implementation





%Write the main body of your essay here. Add more sections if appropriate. You may choose to write about each of your three papers in its own section, or you may choose a different structure. Either way, remember that you are being assessed on technical insight and analysis: it is not enough to merely summarise the contents of the three papers. You must demonstrate the ability to make inferences beyond what is written in the papers, and to draw the three papers together into a single coherent narrative.

\section{Recommendation}

%Your essay must make a clear recommendation, in terms of which of the three techniques you have reviewed is the best according to whichever metric or metrics you feel is most appropriate. You must justify your choice, backing it up with empirical evidence. However remember that an academic essay is not a murder mystery: you should already have briefly discussed your recommendation in the introduction and in other parts of the essay. Do not save it for a grand reveal at the end.

\section{Conclusion}

Write your conclusion here. The conclusion should do more than summarise the essay, making clear the contribution of the work and highlighting key points, limitations, and outstanding questions. It should not introduce any new content or information.

\bibliographystyle{ieeetr}
\bibliography{comp110_architecture}

\end{document}
